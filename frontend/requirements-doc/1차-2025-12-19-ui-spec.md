# Feature Specification: SSH Monitor MVP - UI 명세

## 1. 요구사항 요약

SSH Monitor 1차 개발(MVP)의 프론트엔드를 구현합니다. 단일 SSH 연결 및 터미널 인터랙션을 지원하며, xterm.js를 사용한 웹 터미널과 LocalStorage 기반 연결 정보 관리를 제공합니다.

**핵심 기능:**
- SSH 연결 정보 추가/삭제 (LocalStorage 저장)
- 단일 터미널에서 SSH 연결 및 명령 실행
- 2/7/1 비율의 레이아웃 (왼쪽 사이드바 / 메인 터미널 / 오른쪽 패널)
- WebSocket을 통한 실시간 터미널 I/O

**주의사항:**
- 연결 정보는 클라이언트 LocalStorage에만 저장
- 비밀번호 및 Private Key는 브라우저 메모리에서만 관리

---

## 2. API 명세 (Frontend에서 호출)

### 2.1 REST API 호출

#### 2.1.1 연결 검증

```typescript
// POST /api/connections/validate
interface ValidateConnectionRequest {
  host: string;
  port: number;
  username: string;
  authType: 'password' | 'privateKey';
  password?: string;
  privateKey?: string;
}

interface ValidateConnectionResponse {
  valid: boolean;
  message: string;
  serverInfo?: {
    hostname: string;
    osType: string;
    serverTime: string;
  };
  errorCode?: string;
}
```

#### 2.1.2 서버 정보 조회

```typescript
// POST /api/connections/info
interface GetServerInfoRequest {
  host: string;
  port: number;
  username: string;
  authType: 'password' | 'privateKey';
  password?: string;
  privateKey?: string;
}

interface ServerInfoResponse {
  hostname: string;
  osType: string;
  osVersion: string;
  uptime: string;
  cpuCores: number;
  memoryTotal: string;
  diskUsage: string;
}
```

---

### 2.2 WebSocket 통신

#### 2.2.1 연결

```typescript
// STOMP over WebSocket: /ws/terminal
// Subscribe to: /topic/terminal/{sessionId}

// Connect message to: /app/terminal/connect
interface TerminalConnectMessage {
  sessionId: string;
  host: string;
  port: number;
  username: string;
  authType: 'password' | 'privateKey';
  password?: string;
  privateKey?: string;
  terminalConfig: {
    cols: number;
    rows: number;
    term: string;
  };
}
```

#### 2.2.2 입력

```typescript
// Send to: /app/terminal/input
interface TerminalInputMessage {
  sessionId: string;
  data: string;
}
```

#### 2.2.3 출력 (서버 → 클라이언트)

```typescript
// Receive from: /topic/terminal/{sessionId}
interface TerminalOutputMessage {
  type: 'output' | 'connected' | 'disconnected' | 'error' | 'status' | 'resized';
  sessionId: string;
  data?: string;
  status?: string;
  message?: string;
  errorCode?: string;
  cols?: number;
  rows?: number;
}
```

#### 2.2.4 연결 종료

```typescript
// Send to: /app/terminal/disconnect
interface TerminalDisconnectMessage {
  sessionId: string;
}
```

#### 2.2.5 크기 조정

```typescript
// Send to: /app/terminal/resize
interface TerminalResizeMessage {
  sessionId: string;
  cols: number;
  rows: number;
}
```

---

## 3. UI 명세 (Frontend)

### 3.1 컴포넌트 구조

```
src/
├── App.vue                      # 최상위 앱 컴포넌트
├── views/
│   └── MainView.vue             # 메인 레이아웃 (2/7/1 구조)
├── components/
│   ├── LeftSidebar.vue          # 연결 목록 및 관리
│   ├── TerminalPanel.vue        # xterm.js 터미널
│   ├── RightPanel.vue           # 상태 정보 및 설정
│   ├── ConnectionForm.vue       # 연결 추가 폼 (모달)
│   └── ConnectionItem.vue       # 연결 목록 아이템
├── composables/
│   ├── useSshConnection.ts      # SSH 연결 관리 로직
│   ├── useTerminal.ts           # xterm.js 관리 로직
│   └── useWebSocket.ts          # WebSocket 통신 로직
├── stores/
│   └── connectionStore.ts       # Pinia 스토어 (연결 정보 관리)
└── types/
    ├── connection.ts            # 연결 관련 타입
    ├── terminal.ts              # 터미널 관련 타입
    └── api.ts                   # API 응답 타입
```

---

### 3.2 컴포넌트 상세 명세

#### 3.2.1 App.vue

**Type**: Root Component

**Location**: `src/App.vue`

**Purpose**: 애플리케이션의 최상위 컴포넌트, 라우팅 및 전역 스타일 설정

**템플릿 구조:**
```vue
<template>
  <div id="app">
    <RouterView />
  </div>
</template>

<script setup lang="ts">
import { RouterView } from 'vue-router';
</script>

<style>
/* 전역 스타일 */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body, #app {
  width: 100%;
  height: 100%;
  overflow: hidden;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background-color: #1e1e1e;
  color: #d4d4d4;
}
</style>
```

---

#### 3.2.2 MainView.vue

**Type**: Page Component

**Location**: `src/views/MainView.vue`

**Purpose**: 메인 레이아웃 구성 (2/7/1 비율)

**레이아웃 구조:**
```vue
<template>
  <div class="main-layout">
    <LeftSidebar class="sidebar" />
    <TerminalPanel class="terminal" />
    <RightPanel class="panel" />
  </div>
</template>

<script setup lang="ts">
import LeftSidebar from '@/components/LeftSidebar.vue';
import TerminalPanel from '@/components/TerminalPanel.vue';
import RightPanel from '@/components/RightPanel.vue';
</script>

<style scoped>
.main-layout {
  display: flex;
  width: 100%;
  height: 100vh;
  overflow: hidden;
}

.sidebar {
  flex: 2;
  min-width: 200px;
  max-width: 300px;
  background-color: #252526;
  border-right: 1px solid #3e3e42;
}

.terminal {
  flex: 7;
  background-color: #1e1e1e;
}

.panel {
  flex: 1;
  min-width: 150px;
  max-width: 250px;
  background-color: #252526;
  border-left: 1px solid #3e3e42;
}
</style>
```

---

#### 3.2.3 LeftSidebar.vue

**Type**: Component

**Location**: `src/components/LeftSidebar.vue`

**Purpose**: SSH 연결 목록 표시 및 연결 추가/삭제 기능

**Props**: 없음

**State Management:**
- Pinia Store: `useConnectionStore`
  - `connections`: 저장된 연결 목록 (LocalStorage와 동기화)
  - `selectedConnectionId`: 현재 선택된 연결 ID
  - `addConnection()`: 연결 추가
  - `removeConnection()`: 연결 삭제
  - `selectConnection()`: 연결 선택

**Local State:**
```typescript
const showAddForm = ref(false);  // 연결 추가 폼 표시 여부
```

**User Interactions:**
- "연결 추가" 버튼 클릭 → `showAddForm = true` → ConnectionForm 모달 표시
- 연결 아이템 클릭 → `selectConnection(id)` → 터미널에 연결 시도
- 연결 삭제 버튼 클릭 → `removeConnection(id)` → LocalStorage 업데이트

**템플릿 구조:**
```vue
<template>
  <div class="left-sidebar">
    <div class="header">
      <h2>SSH Connections</h2>
      <button @click="showAddForm = true" class="add-btn">
        + Add
      </button>
    </div>

    <div class="connection-list">
      <ConnectionItem
        v-for="conn in connections"
        :key="conn.id"
        :connection="conn"
        :isSelected="conn.id === selectedConnectionId"
        @select="selectConnection(conn.id)"
        @delete="removeConnection(conn.id)"
      />

      <div v-if="connections.length === 0" class="empty-state">
        No connections. Click "Add" to create one.
      </div>
    </div>

    <ConnectionForm
      v-if="showAddForm"
      @close="showAddForm = false"
      @save="handleSaveConnection"
    />
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import { storeToRefs } from 'pinia';
import { useConnectionStore } from '@/stores/connectionStore';
import ConnectionItem from './ConnectionItem.vue';
import ConnectionForm from './ConnectionForm.vue';
import type { SshConnection } from '@/types/connection';

const connectionStore = useConnectionStore();
const { connections, selectedConnectionId } = storeToRefs(connectionStore);
const { selectConnection, removeConnection, addConnection } = connectionStore;

const showAddForm = ref(false);

const handleSaveConnection = (connection: SshConnection) => {
  addConnection(connection);
  showAddForm.value = false;
};
</script>

<style scoped>
.left-sidebar {
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border-bottom: 1px solid #3e3e42;
}

.header h2 {
  font-size: 16px;
  font-weight: 600;
}

.add-btn {
  padding: 6px 12px;
  background-color: #0e639c;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
}

.add-btn:hover {
  background-color: #1177bb;
}

.connection-list {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.empty-state {
  padding: 24px 16px;
  text-align: center;
  color: #858585;
  font-size: 14px;
}
</style>
```

---

#### 3.2.4 ConnectionItem.vue

**Type**: Component

**Location**: `src/components/ConnectionItem.vue`

**Purpose**: 개별 연결 정보를 카드 형태로 표시

**Props:**
```typescript
interface Props {
  connection: SshConnection;
  isSelected: boolean;
}
```

**Emits:**
```typescript
interface Emits {
  (e: 'select'): void;
  (e: 'delete'): void;
}
```

**템플릿 구조:**
```vue
<template>
  <div
    class="connection-item"
    :class="{ selected: isSelected }"
    @click="emit('select')"
  >
    <div class="connection-info">
      <div class="connection-name">{{ connection.name }}</div>
      <div class="connection-details">
        {{ connection.username }}@{{ connection.host }}:{{ connection.port }}
      </div>
    </div>
    <button
      class="delete-btn"
      @click.stop="handleDelete"
      title="Delete connection"
    >
      ✕
    </button>
  </div>
</template>

<script setup lang="ts">
import type { SshConnection } from '@/types/connection';

interface Props {
  connection: SshConnection;
  isSelected: boolean;
}

interface Emits {
  (e: 'select'): void;
  (e: 'delete'): void;
}

defineProps<Props>();
const emit = defineEmits<Emits>();

const handleDelete = () => {
  if (confirm(`Delete connection "${props.connection.name}"?`)) {
    emit('delete');
  }
};
</script>

<style scoped>
.connection-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px;
  margin-bottom: 4px;
  background-color: #2d2d30;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.connection-item:hover {
  background-color: #37373d;
}

.connection-item.selected {
  background-color: #094771;
  border-left: 3px solid #0e639c;
}

.connection-info {
  flex: 1;
  min-width: 0;
}

.connection-name {
  font-weight: 600;
  font-size: 14px;
  margin-bottom: 4px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.connection-details {
  font-size: 12px;
  color: #858585;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.delete-btn {
  padding: 4px 8px;
  background: transparent;
  color: #858585;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  opacity: 0;
  transition: opacity 0.2s, background-color 0.2s;
}

.connection-item:hover .delete-btn {
  opacity: 1;
}

.delete-btn:hover {
  background-color: #c74e39;
  color: white;
}
</style>
```

---

#### 3.2.5 ConnectionForm.vue

**Type**: Component (Modal)

**Location**: `src/components/ConnectionForm.vue`

**Purpose**: 새로운 SSH 연결 정보 입력 폼

**Props**: 없음

**Emits:**
```typescript
interface Emits {
  (e: 'close'): void;
  (e: 'save', connection: SshConnection): void;
}
```

**Local State:**
```typescript
const formData = reactive({
  name: '',
  host: '',
  port: 22,
  username: '',
  authType: 'password' as 'password' | 'privateKey',
  password: '',
  privateKey: '',
});

const errors = reactive({
  name: '',
  host: '',
  username: '',
  password: '',
  privateKey: '',
});

const isValidating = ref(false);
```

**Validation Rules:**
- `name`: 필수, 최소 1자 이상
- `host`: 필수, IP 또는 도메인 형식
- `port`: 1-65535 범위
- `username`: 필수
- `password`: authType이 'password'일 때 필수
- `privateKey`: authType이 'privateKey'일 때 필수

**User Interactions:**
1. 폼 입력 → 실시간 validation
2. "Test Connection" 버튼 클릭 → `/api/connections/validate` 호출
3. "Save" 버튼 클릭 → 유효성 검증 후 `emit('save')` 및 LocalStorage 저장
4. "Cancel" 버튼 클릭 → `emit('close')`

**템플릿 구조:**
```vue
<template>
  <div class="modal-overlay" @click.self="emit('close')">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Add SSH Connection</h3>
        <button @click="emit('close')" class="close-btn">✕</button>
      </div>

      <form @submit.prevent="handleSubmit" class="connection-form">
        <div class="form-group">
          <label for="name">Connection Name *</label>
          <input
            id="name"
            v-model="formData.name"
            type="text"
            placeholder="My Server"
            @blur="validateName"
          />
          <span v-if="errors.name" class="error">{{ errors.name }}</span>
        </div>

        <div class="form-row">
          <div class="form-group">
            <label for="host">Host *</label>
            <input
              id="host"
              v-model="formData.host"
              type="text"
              placeholder="192.168.1.100"
              @blur="validateHost"
            />
            <span v-if="errors.host" class="error">{{ errors.host }}</span>
          </div>

          <div class="form-group">
            <label for="port">Port</label>
            <input
              id="port"
              v-model.number="formData.port"
              type="number"
              min="1"
              max="65535"
            />
          </div>
        </div>

        <div class="form-group">
          <label for="username">Username *</label>
          <input
            id="username"
            v-model="formData.username"
            type="text"
            placeholder="root"
            @blur="validateUsername"
          />
          <span v-if="errors.username" class="error">{{ errors.username }}</span>
        </div>

        <div class="form-group">
          <label>Authentication Type</label>
          <div class="radio-group">
            <label>
              <input
                v-model="formData.authType"
                type="radio"
                value="password"
              />
              Password
            </label>
            <label>
              <input
                v-model="formData.authType"
                type="radio"
                value="privateKey"
              />
              Private Key
            </label>
          </div>
        </div>

        <div v-if="formData.authType === 'password'" class="form-group">
          <label for="password">Password *</label>
          <input
            id="password"
            v-model="formData.password"
            type="password"
            placeholder="••••••••"
            @blur="validatePassword"
          />
          <span v-if="errors.password" class="error">{{ errors.password }}</span>
        </div>

        <div v-else class="form-group">
          <label for="privateKey">Private Key (PEM format) *</label>
          <textarea
            id="privateKey"
            v-model="formData.privateKey"
            rows="6"
            placeholder="-----BEGIN RSA PRIVATE KEY-----"
            @blur="validatePrivateKey"
          />
          <span v-if="errors.privateKey" class="error">{{ errors.privateKey }}</span>
        </div>

        <div class="form-actions">
          <button
            type="button"
            @click="testConnection"
            :disabled="isValidating"
            class="test-btn"
          >
            {{ isValidating ? 'Testing...' : 'Test Connection' }}
          </button>
          <div class="right-actions">
            <button type="button" @click="emit('close')" class="cancel-btn">
              Cancel
            </button>
            <button type="submit" class="save-btn">
              Save
            </button>
          </div>
        </div>
      </form>
    </div>
  </div>
</template>

<script setup lang="ts">
import { reactive, ref } from 'vue';
import { useSshConnection } from '@/composables/useSshConnection';
import type { SshConnection } from '@/types/connection';

interface Emits {
  (e: 'close'): void;
  (e: 'save', connection: SshConnection): void;
}

const emit = defineEmits<Emits>();
const { validateConnection } = useSshConnection();

const formData = reactive({
  name: '',
  host: '',
  port: 22,
  username: '',
  authType: 'password' as 'password' | 'privateKey',
  password: '',
  privateKey: '',
});

const errors = reactive({
  name: '',
  host: '',
  username: '',
  password: '',
  privateKey: '',
});

const isValidating = ref(false);

const validateName = () => {
  errors.name = formData.name.trim() ? '' : 'Name is required';
};

const validateHost = () => {
  errors.host = formData.host.trim() ? '' : 'Host is required';
};

const validateUsername = () => {
  errors.username = formData.username.trim() ? '' : 'Username is required';
};

const validatePassword = () => {
  if (formData.authType === 'password') {
    errors.password = formData.password ? '' : 'Password is required';
  }
};

const validatePrivateKey = () => {
  if (formData.authType === 'privateKey') {
    errors.privateKey = formData.privateKey ? '' : 'Private key is required';
  }
};

const validateAll = (): boolean => {
  validateName();
  validateHost();
  validateUsername();
  if (formData.authType === 'password') {
    validatePassword();
  } else {
    validatePrivateKey();
  }

  return !Object.values(errors).some(error => error !== '');
};

const testConnection = async () => {
  if (!validateAll()) return;

  isValidating.value = true;
  try {
    const result = await validateConnection({
      host: formData.host,
      port: formData.port,
      username: formData.username,
      authType: formData.authType,
      password: formData.authType === 'password' ? formData.password : undefined,
      privateKey: formData.authType === 'privateKey' ? formData.privateKey : undefined,
    });

    if (result.valid) {
      alert(`Connection successful!\nServer: ${result.serverInfo?.hostname}`);
    } else {
      alert(`Connection failed: ${result.message}`);
    }
  } catch (error) {
    alert('Test connection failed: ' + (error as Error).message);
  } finally {
    isValidating.value = false;
  }
};

const handleSubmit = () => {
  if (!validateAll()) return;

  const connection: SshConnection = {
    id: crypto.randomUUID(),
    name: formData.name,
    host: formData.host,
    port: formData.port,
    username: formData.username,
    authType: formData.authType,
    password: formData.authType === 'password' ? formData.password : undefined,
    privateKey: formData.authType === 'privateKey' ? formData.privateKey : undefined,
    createdAt: new Date().toISOString(),
  };

  emit('save', connection);
};
</script>

<style scoped>
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background-color: #252526;
  border-radius: 8px;
  width: 90%;
  max-width: 600px;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 24px;
  border-bottom: 1px solid #3e3e42;
}

.modal-header h3 {
  font-size: 18px;
  font-weight: 600;
}

.close-btn {
  background: transparent;
  border: none;
  color: #d4d4d4;
  font-size: 20px;
  cursor: pointer;
  padding: 4px;
}

.close-btn:hover {
  color: white;
}

.connection-form {
  padding: 24px;
}

.form-group {
  margin-bottom: 20px;
}

.form-row {
  display: grid;
  grid-template-columns: 2fr 1fr;
  gap: 16px;
}

label {
  display: block;
  margin-bottom: 8px;
  font-size: 14px;
  font-weight: 500;
}

input[type="text"],
input[type="password"],
input[type="number"],
textarea {
  width: 100%;
  padding: 8px 12px;
  background-color: #3c3c3c;
  border: 1px solid #555;
  border-radius: 4px;
  color: #d4d4d4;
  font-size: 14px;
}

input:focus,
textarea:focus {
  outline: none;
  border-color: #0e639c;
}

textarea {
  font-family: 'Courier New', monospace;
  resize: vertical;
}

.radio-group {
  display: flex;
  gap: 16px;
}

.radio-group label {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 0;
}

.error {
  display: block;
  margin-top: 4px;
  color: #f48771;
  font-size: 12px;
}

.form-actions {
  display: flex;
  justify-content: space-between;
  margin-top: 24px;
  padding-top: 16px;
  border-top: 1px solid #3e3e42;
}

.right-actions {
  display: flex;
  gap: 8px;
}

button {
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.test-btn {
  background-color: #2d2d30;
  color: #d4d4d4;
}

.test-btn:hover:not(:disabled) {
  background-color: #37373d;
}

.test-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.cancel-btn {
  background-color: #3c3c3c;
  color: #d4d4d4;
}

.cancel-btn:hover {
  background-color: #4e4e4e;
}

.save-btn {
  background-color: #0e639c;
  color: white;
}

.save-btn:hover {
  background-color: #1177bb;
}
</style>
```

---

#### 3.2.6 TerminalPanel.vue

**Type**: Component

**Location**: `src/components/TerminalPanel.vue`

**Purpose**: xterm.js 터미널 표시 및 WebSocket 통신

**Props**: 없음

**State Management:**
- Pinia Store: `useConnectionStore`
  - `selectedConnection`: 현재 선택된 연결 정보
- Composables:
  - `useTerminal()`: xterm.js 인스턴스 관리
  - `useWebSocket()`: WebSocket 연결 및 메시지 처리

**Local State:**
```typescript
const terminalRef = ref<HTMLElement>();
const isConnected = ref(false);
const isConnecting = ref(false);
const errorMessage = ref('');
```

**Lifecycle:**
1. **onMounted**: xterm.js 인스턴스 생성 및 DOM 마운트
2. **watch(selectedConnection)**: 연결 변경 시 WebSocket 연결 시도
3. **onUnmounted**: 터미널 및 WebSocket 정리

**User Interactions:**
- 사용자 키 입력 → xterm.js onData → WebSocket으로 전송
- WebSocket 메시지 수신 → xterm.js에 출력
- 터미널 크기 변경 → resize 이벤트 → WebSocket으로 크기 전송

**템플릿 구조:**
```vue
<template>
  <div class="terminal-panel">
    <div class="terminal-toolbar">
      <div class="connection-status">
        <span
          class="status-indicator"
          :class="{
            connected: isConnected,
            connecting: isConnecting,
            disconnected: !isConnected && !isConnecting
          }"
        />
        <span class="status-text">
          {{ statusText }}
        </span>
      </div>

      <button
        v-if="isConnected"
        @click="handleDisconnect"
        class="disconnect-btn"
      >
        Disconnect
      </button>
    </div>

    <div
      ref="terminalRef"
      class="terminal-container"
    />

    <div v-if="errorMessage" class="error-overlay">
      <div class="error-content">
        <h3>Connection Error</h3>
        <p>{{ errorMessage }}</p>
        <button @click="errorMessage = ''" class="close-error-btn">
          Close
        </button>
      </div>
    </div>

    <div v-if="!selectedConnection && !isConnected" class="welcome-screen">
      <h2>Welcome to SSH Monitor</h2>
      <p>Select or add a connection from the left sidebar to get started.</p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch, onMounted, onUnmounted } from 'vue';
import { storeToRefs } from 'pinia';
import { useConnectionStore } from '@/stores/connectionStore';
import { useTerminal } from '@/composables/useTerminal';
import { useWebSocket } from '@/composables/useWebSocket';

const connectionStore = useConnectionStore();
const { selectedConnection } = storeToRefs(connectionStore);

const terminalRef = ref<HTMLElement>();
const isConnected = ref(false);
const isConnecting = ref(false);
const errorMessage = ref('');

const { terminal, initTerminal, fitTerminal, disposeTerminal, writeToTerminal } = useTerminal();
const {
  connect: wsConnect,
  disconnect: wsDisconnect,
  sendInput,
  sendResize,
  isConnected: wsIsConnected,
  onMessage,
  onError,
  onClose,
} = useWebSocket();

const statusText = computed(() => {
  if (isConnecting.value) return 'Connecting...';
  if (isConnected.value) return `Connected to ${selectedConnection.value?.name}`;
  return 'Disconnected';
});

// 터미널 초기화
onMounted(() => {
  if (terminalRef.value) {
    initTerminal(terminalRef.value);

    // xterm.js 데이터 이벤트 → WebSocket으로 전송
    terminal.value?.onData((data: string) => {
      if (isConnected.value) {
        sendInput(data);
      }
    });

    // 윈도우 리사이즈 이벤트
    window.addEventListener('resize', handleResize);
  }
});

onUnmounted(() => {
  disposeTerminal();
  wsDisconnect();
  window.removeEventListener('resize', handleResize);
});

// 선택된 연결 변경 시 SSH 연결 시도
watch(selectedConnection, async (newConnection) => {
  if (!newConnection) return;

  // 기존 연결 종료
  if (isConnected.value) {
    wsDisconnect();
    isConnected.value = false;
  }

  // 터미널 초기화
  terminal.value?.clear();
  errorMessage.value = '';
  isConnecting.value = true;

  try {
    // WebSocket 연결
    await wsConnect({
      sessionId: crypto.randomUUID(),
      host: newConnection.host,
      port: newConnection.port,
      username: newConnection.username,
      authType: newConnection.authType,
      password: newConnection.password,
      privateKey: newConnection.privateKey,
      terminalConfig: {
        cols: terminal.value?.cols || 80,
        rows: terminal.value?.rows || 24,
        term: 'xterm-256color',
      },
    });

    isConnected.value = true;
    isConnecting.value = false;
  } catch (error) {
    isConnecting.value = false;
    errorMessage.value = (error as Error).message;
  }
});

// WebSocket 메시지 수신
onMessage((message) => {
  switch (message.type) {
    case 'connected':
      writeToTerminal(`\r\n✓ Connected to ${selectedConnection.value?.name}\r\n`);
      break;
    case 'output':
      if (message.data) {
        writeToTerminal(message.data);
      }
      break;
    case 'error':
      errorMessage.value = message.message || 'Unknown error';
      isConnected.value = false;
      break;
    case 'disconnected':
      writeToTerminal('\r\n✗ Connection closed\r\n');
      isConnected.value = false;
      break;
  }
});

// WebSocket 에러
onError((error) => {
  errorMessage.value = `WebSocket error: ${error}`;
  isConnected.value = false;
});

// WebSocket 종료
onClose(() => {
  if (isConnected.value) {
    writeToTerminal('\r\n✗ Connection lost\r\n');
    isConnected.value = false;
  }
});

// 연결 종료
const handleDisconnect = () => {
  wsDisconnect();
  isConnected.value = false;
  terminal.value?.clear();
};

// 터미널 크기 조정
const handleResize = () => {
  fitTerminal();
  if (isConnected.value && terminal.value) {
    sendResize(terminal.value.cols, terminal.value.rows);
  }
};
</script>

<style scoped>
.terminal-panel {
  display: flex;
  flex-direction: column;
  height: 100%;
  position: relative;
}

.terminal-toolbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 16px;
  background-color: #2d2d30;
  border-bottom: 1px solid #3e3e42;
}

.connection-status {
  display: flex;
  align-items: center;
  gap: 8px;
}

.status-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
}

.status-indicator.connected {
  background-color: #4ec9b0;
}

.status-indicator.connecting {
  background-color: #ce9178;
  animation: pulse 1.5s infinite;
}

.status-indicator.disconnected {
  background-color: #858585;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.status-text {
  font-size: 14px;
  color: #d4d4d4;
}

.disconnect-btn {
  padding: 4px 12px;
  background-color: #c74e39;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 13px;
}

.disconnect-btn:hover {
  background-color: #e05141;
}

.terminal-container {
  flex: 1;
  padding: 8px;
  overflow: hidden;
}

.welcome-screen {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  color: #858585;
}

.welcome-screen h2 {
  font-size: 24px;
  margin-bottom: 12px;
}

.welcome-screen p {
  font-size: 14px;
}

.error-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 100;
}

.error-content {
  background-color: #3e1e1e;
  border: 1px solid #be1100;
  border-radius: 8px;
  padding: 24px;
  max-width: 500px;
  text-align: center;
}

.error-content h3 {
  color: #f48771;
  margin-bottom: 12px;
}

.error-content p {
  color: #d4d4d4;
  margin-bottom: 16px;
}

.close-error-btn {
  padding: 8px 16px;
  background-color: #0e639c;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.close-error-btn:hover {
  background-color: #1177bb;
}
</style>
```

---

#### 3.2.7 RightPanel.vue

**Type**: Component

**Location**: `src/components/RightPanel.vue`

**Purpose**: 연결 상태 정보 및 서버 정보 표시

**Props**: 없음

**State Management:**
- Pinia Store: `useConnectionStore`
  - `selectedConnection`: 현재 선택된 연결 정보
- Composables:
  - `useSshConnection()`: 서버 정보 조회

**Local State:**
```typescript
const serverInfo = ref<ServerInfoResponse | null>(null);
const isLoading = ref(false);
```

**API Calls:**
- `GET /api/connections/info`: 선택된 연결의 서버 정보 조회

**User Interactions:**
- "Refresh" 버튼 클릭 → 서버 정보 재조회

**템플릿 구조:**
```vue
<template>
  <div class="right-panel">
    <div class="panel-header">
      <h3>Server Info</h3>
      <button
        v-if="selectedConnection"
        @click="fetchServerInfo"
        :disabled="isLoading"
        class="refresh-btn"
      >
        {{ isLoading ? '...' : '↻' }}
      </button>
    </div>

    <div v-if="!selectedConnection" class="empty-state">
      No connection selected
    </div>

    <div v-else-if="serverInfo" class="info-content">
      <div class="info-item">
        <span class="label">Hostname</span>
        <span class="value">{{ serverInfo.hostname }}</span>
      </div>
      <div class="info-item">
        <span class="label">OS</span>
        <span class="value">{{ serverInfo.osType }} {{ serverInfo.osVersion }}</span>
      </div>
      <div class="info-item">
        <span class="label">Uptime</span>
        <span class="value">{{ serverInfo.uptime }}</span>
      </div>
      <div class="info-item">
        <span class="label">CPU Cores</span>
        <span class="value">{{ serverInfo.cpuCores }}</span>
      </div>
      <div class="info-item">
        <span class="label">Memory</span>
        <span class="value">{{ serverInfo.memoryTotal }}</span>
      </div>
      <div class="info-item">
        <span class="label">Disk Usage</span>
        <span class="value">{{ serverInfo.diskUsage }}</span>
      </div>
    </div>

    <div v-else class="empty-state">
      Click refresh to load server info
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watch } from 'vue';
import { storeToRefs } from 'pinia';
import { useConnectionStore } from '@/stores/connectionStore';
import { useSshConnection } from '@/composables/useSshConnection';
import type { ServerInfoResponse } from '@/types/api';

const connectionStore = useConnectionStore();
const { selectedConnection } = storeToRefs(connectionStore);
const { getServerInfo } = useSshConnection();

const serverInfo = ref<ServerInfoResponse | null>(null);
const isLoading = ref(false);

watch(selectedConnection, () => {
  serverInfo.value = null;
});

const fetchServerInfo = async () => {
  if (!selectedConnection.value) return;

  isLoading.value = true;
  try {
    serverInfo.value = await getServerInfo({
      host: selectedConnection.value.host,
      port: selectedConnection.value.port,
      username: selectedConnection.value.username,
      authType: selectedConnection.value.authType,
      password: selectedConnection.value.password,
      privateKey: selectedConnection.value.privateKey,
    });
  } catch (error) {
    console.error('Failed to fetch server info:', error);
    alert('Failed to fetch server info');
  } finally {
    isLoading.value = false;
  }
};
</script>

<style scoped>
.right-panel {
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow-y: auto;
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border-bottom: 1px solid #3e3e42;
}

.panel-header h3 {
  font-size: 16px;
  font-weight: 600;
}

.refresh-btn {
  padding: 4px 8px;
  background-color: #2d2d30;
  color: #d4d4d4;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
}

.refresh-btn:hover:not(:disabled) {
  background-color: #37373d;
}

.refresh-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.empty-state {
  padding: 24px 16px;
  text-align: center;
  color: #858585;
  font-size: 14px;
}

.info-content {
  padding: 16px;
}

.info-item {
  display: flex;
  flex-direction: column;
  margin-bottom: 16px;
}

.label {
  font-size: 12px;
  color: #858585;
  margin-bottom: 4px;
}

.value {
  font-size: 14px;
  color: #d4d4d4;
  word-break: break-all;
}
</style>
```

---

### 3.3 상태 관리 (Pinia Store)

#### 3.3.1 connectionStore.ts

**Location**: `src/stores/connectionStore.ts`

**Purpose**: SSH 연결 정보를 LocalStorage와 동기화하여 관리

**State:**
```typescript
interface ConnectionState {
  connections: SshConnection[];
  selectedConnectionId: string | null;
}
```

**Getters:**
```typescript
selectedConnection: (state) => SshConnection | undefined
```

**Actions:**
```typescript
loadConnections(): void          // LocalStorage에서 연결 목록 로드
saveConnections(): void          // LocalStorage에 연결 목록 저장
addConnection(conn): void        // 연결 추가
removeConnection(id): void       // 연결 삭제
selectConnection(id): void       // 연결 선택
```

**구현:**
```typescript
import { defineStore } from 'pinia';
import type { SshConnection } from '@/types/connection';

const STORAGE_KEY = 'ssh-monitor-connections';

interface ConnectionState {
  connections: SshConnection[];
  selectedConnectionId: string | null;
}

export const useConnectionStore = defineStore('connection', {
  state: (): ConnectionState => ({
    connections: [],
    selectedConnectionId: null,
  }),

  getters: {
    selectedConnection(state): SshConnection | undefined {
      if (!state.selectedConnectionId) return undefined;
      return state.connections.find(conn => conn.id === state.selectedConnectionId);
    },
  },

  actions: {
    loadConnections() {
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
          this.connections = JSON.parse(stored);
        }
      } catch (error) {
        console.error('Failed to load connections from localStorage:', error);
      }
    },

    saveConnections() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(this.connections));
      } catch (error) {
        console.error('Failed to save connections to localStorage:', error);
      }
    },

    addConnection(connection: SshConnection) {
      this.connections.push(connection);
      this.saveConnections();
    },

    removeConnection(id: string) {
      this.connections = this.connections.filter(conn => conn.id !== id);
      if (this.selectedConnectionId === id) {
        this.selectedConnectionId = null;
      }
      this.saveConnections();
    },

    selectConnection(id: string) {
      this.selectedConnectionId = id;
    },
  },
});
```

---

### 3.4 Composables

#### 3.4.1 useSshConnection.ts

**Location**: `src/composables/useSshConnection.ts`

**Purpose**: SSH 연결 관련 API 호출 로직

**Methods:**
```typescript
validateConnection(request): Promise<ConnectionValidationResponse>
getServerInfo(request): Promise<ServerInfoResponse>
```

**구현:**
```typescript
import type {
  ValidateConnectionRequest,
  ValidateConnectionResponse,
  GetServerInfoRequest,
  ServerInfoResponse,
} from '@/types/api';

export function useSshConnection() {
  const API_BASE = '/api';

  const validateConnection = async (
    request: ValidateConnectionRequest
  ): Promise<ValidateConnectionResponse> => {
    const response = await fetch(`${API_BASE}/connections/validate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    return await response.json();
  };

  const getServerInfo = async (
    request: GetServerInfoRequest
  ): Promise<ServerInfoResponse> => {
    const response = await fetch(`${API_BASE}/connections/info`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    return await response.json();
  };

  return {
    validateConnection,
    getServerInfo,
  };
}
```

---

#### 3.4.2 useTerminal.ts

**Location**: `src/composables/useTerminal.ts`

**Purpose**: xterm.js 인스턴스 생성 및 관리

**Dependencies:**
```bash
npm install xterm @xterm/addon-fit
```

**Methods:**
```typescript
initTerminal(element): void
fitTerminal(): void
writeToTerminal(data): void
disposeTerminal(): void
```

**구현:**
```typescript
import { ref } from 'vue';
import { Terminal } from 'xterm';
import { FitAddon } from '@xterm/addon-fit';
import 'xterm/css/xterm.css';

export function useTerminal() {
  const terminal = ref<Terminal>();
  const fitAddon = ref<FitAddon>();

  const initTerminal = (element: HTMLElement) => {
    terminal.value = new Terminal({
      cursorBlink: true,
      fontSize: 14,
      fontFamily: 'Menlo, Monaco, "Courier New", monospace',
      theme: {
        background: '#1e1e1e',
        foreground: '#d4d4d4',
        cursor: '#d4d4d4',
        selection: '#264f78',
        black: '#000000',
        red: '#cd3131',
        green: '#0dbc79',
        yellow: '#e5e510',
        blue: '#2472c8',
        magenta: '#bc3fbc',
        cyan: '#11a8cd',
        white: '#e5e5e5',
        brightBlack: '#666666',
        brightRed: '#f14c4c',
        brightGreen: '#23d18b',
        brightYellow: '#f5f543',
        brightBlue: '#3b8eea',
        brightMagenta: '#d670d6',
        brightCyan: '#29b8db',
        brightWhite: '#e5e5e5',
      },
    });

    fitAddon.value = new FitAddon();
    terminal.value.loadAddon(fitAddon.value);

    terminal.value.open(element);
    fitAddon.value.fit();
  };

  const fitTerminal = () => {
    fitAddon.value?.fit();
  };

  const writeToTerminal = (data: string) => {
    terminal.value?.write(data);
  };

  const disposeTerminal = () => {
    terminal.value?.dispose();
    terminal.value = undefined;
  };

  return {
    terminal,
    initTerminal,
    fitTerminal,
    writeToTerminal,
    disposeTerminal,
  };
}
```

---

#### 3.4.3 useWebSocket.ts

**Location**: `src/composables/useWebSocket.ts`

**Purpose**: STOMP over WebSocket 통신 관리

**Dependencies:**
```bash
npm install @stomp/stompjs sockjs-client
```

**Methods:**
```typescript
connect(request): Promise<void>
disconnect(): void
sendInput(data): void
sendResize(cols, rows): void
onMessage(callback): void
onError(callback): void
onClose(callback): void
```

**구현:**
```typescript
import { ref } from 'vue';
import { Client, StompSubscription } from '@stomp/stompjs';
import SockJS from 'sockjs-client';
import type { TerminalConnectRequest, TerminalOutputMessage } from '@/types/terminal';

export function useWebSocket() {
  const client = ref<Client>();
  const subscription = ref<StompSubscription>();
  const sessionId = ref<string>();
  const isConnected = ref(false);

  const messageCallbacks = ref<Array<(message: TerminalOutputMessage) => void>>([]);
  const errorCallbacks = ref<Array<(error: string) => void>>([]);
  const closeCallbacks = ref<Array<() => void>>([]);

  const connect = (request: TerminalConnectRequest): Promise<void> => {
    return new Promise((resolve, reject) => {
      sessionId.value = request.sessionId;

      client.value = new Client({
        webSocketFactory: () => new SockJS('/ws/terminal'),
        reconnectDelay: 5000,
        heartbeatIncoming: 4000,
        heartbeatOutgoing: 4000,

        onConnect: () => {
          console.log('WebSocket connected');

          // 구독 설정
          subscription.value = client.value?.subscribe(
            `/topic/terminal/${sessionId.value}`,
            (message) => {
              const data: TerminalOutputMessage = JSON.parse(message.body);
              messageCallbacks.value.forEach(cb => cb(data));
            }
          );

          // 연결 메시지 전송
          client.value?.publish({
            destination: '/app/terminal/connect',
            body: JSON.stringify(request),
          });

          isConnected.value = true;
          resolve();
        },

        onStompError: (frame) => {
          console.error('STOMP error:', frame);
          const errorMsg = frame.headers['message'] || 'Unknown STOMP error';
          errorCallbacks.value.forEach(cb => cb(errorMsg));
          reject(new Error(errorMsg));
        },

        onWebSocketError: (event) => {
          console.error('WebSocket error:', event);
          errorCallbacks.value.forEach(cb => cb('WebSocket connection error'));
          reject(new Error('WebSocket connection error'));
        },

        onWebSocketClose: () => {
          console.log('WebSocket closed');
          isConnected.value = false;
          closeCallbacks.value.forEach(cb => cb());
        },
      });

      client.value.activate();
    });
  };

  const disconnect = () => {
    if (sessionId.value && isConnected.value) {
      client.value?.publish({
        destination: '/app/terminal/disconnect',
        body: JSON.stringify({ sessionId: sessionId.value }),
      });
    }

    subscription.value?.unsubscribe();
    client.value?.deactivate();
    isConnected.value = false;
    sessionId.value = undefined;
  };

  const sendInput = (data: string) => {
    if (!sessionId.value || !isConnected.value) return;

    client.value?.publish({
      destination: '/app/terminal/input',
      body: JSON.stringify({
        sessionId: sessionId.value,
        data,
      }),
    });
  };

  const sendResize = (cols: number, rows: number) => {
    if (!sessionId.value || !isConnected.value) return;

    client.value?.publish({
      destination: '/app/terminal/resize',
      body: JSON.stringify({
        sessionId: sessionId.value,
        cols,
        rows,
      }),
    });
  };

  const onMessage = (callback: (message: TerminalOutputMessage) => void) => {
    messageCallbacks.value.push(callback);
  };

  const onError = (callback: (error: string) => void) => {
    errorCallbacks.value.push(callback);
  };

  const onClose = (callback: () => void) => {
    closeCallbacks.value.push(callback);
  };

  return {
    connect,
    disconnect,
    sendInput,
    sendResize,
    isConnected,
    onMessage,
    onError,
    onClose,
  };
}
```

---

### 3.5 TypeScript 타입 정의

#### 3.5.1 connection.ts

**Location**: `src/types/connection.ts`

```typescript
export interface SshConnection {
  id: string;
  name: string;
  host: string;
  port: number;
  username: string;
  authType: 'password' | 'privateKey';
  password?: string;
  privateKey?: string;
  createdAt: string;
}
```

---

#### 3.5.2 terminal.ts

**Location**: `src/types/terminal.ts`

```typescript
export interface TerminalConnectRequest {
  sessionId: string;
  host: string;
  port: number;
  username: string;
  authType: 'password' | 'privateKey';
  password?: string;
  privateKey?: string;
  terminalConfig: {
    cols: number;
    rows: number;
    term: string;
  };
}

export interface TerminalOutputMessage {
  type: 'output' | 'connected' | 'disconnected' | 'error' | 'status' | 'resized';
  sessionId: string;
  data?: string;
  status?: string;
  message?: string;
  errorCode?: string;
  cols?: number;
  rows?: number;
}
```

---

#### 3.5.3 api.ts

**Location**: `src/types/api.ts`

```typescript
export interface ValidateConnectionRequest {
  host: string;
  port: number;
  username: string;
  authType: 'password' | 'privateKey';
  password?: string;
  privateKey?: string;
}

export interface ValidateConnectionResponse {
  valid: boolean;
  message: string;
  serverInfo?: {
    hostname: string;
    osType: string;
    serverTime: string;
  };
  errorCode?: string;
}

export interface GetServerInfoRequest {
  host: string;
  port: number;
  username: string;
  authType: 'password' | 'privateKey';
  password?: string;
  privateKey?: string;
}

export interface ServerInfoResponse {
  hostname: string;
  osType: string;
  osVersion: string;
  uptime: string;
  cpuCores: number;
  memoryTotal: string;
  diskUsage: string;
}
```

---

## 4. 데이터 흐름

### 4.1 연결 추가 플로우

```
User                    UI Component              Pinia Store          LocalStorage
  |                          |                         |                      |
  |-- Click "Add" ---------> |                         |                      |
  |                          |-- Show Modal ---------->|                      |
  |                          |                         |                      |
  |-- Fill Form -----------> |                         |                      |
  |-- Click "Test" --------> |-- validateConnection()->|                      |
  |                          |     (API Call)          |                      |
  |<-- Result -------------- |                         |                      |
  |                          |                         |                      |
  |-- Click "Save" --------> |-- emit('save') -------> |                      |
  |                          |                         |-- addConnection() -->|
  |                          |                         |                      |-- setItem()
  |                          |<-- Update ------------- |<-------------------- |
  |<-- Modal Close --------- |                         |                      |
```

---

### 4.2 SSH 연결 및 터미널 통신 플로우

```
User         TerminalPanel      WebSocket         Backend         SSH Server
  |                |                |                 |                  |
  |-- Select ----> |                |                 |                  |
  |                |-- connect() -->|                 |                  |
  |                |                |-- CONNECT ----->|                  |
  |                |                |                 |-- SSHD --------->|
  |                |                |<-- CONNECTED ---|<-- Session ------|
  |                |<-- onMessage --|                 |                  |
  |<-- Display ----| (connected)    |                 |                  |
  |                |                |                 |                  |
  |-- Type "ls" -->|                |                 |                  |
  |                |-- sendInput()->|-- INPUT ------->|-- write() ------>|
  |                |                |                 |<-- read() -------|
  |                |                |<-- OUTPUT ------|                  |
  |                |<-- onMessage --|                 |                  |
  |<-- Display ----| (output)       |                 |                  |
  |                |                |                 |                  |
  |(User continues typing and receiving output...)                      |
  |                |                |                 |                  |
  |-- Disconnect ->|                |                 |                  |
  |                |-- disconnect()->|-- DISCONNECT -->|                  |
  |                |                |                 |-- cleanup() ---->|
  |                |                |<-- DISCONNECTED-|<-- close --------|
  |                |<-- onClose ----| |               |                  |
  |<-- Display ----| (disconnected)  |                 |                  |
```

---

### 4.3 서버 정보 조회 플로우

```
User          RightPanel       API                Backend           SSH Server
  |                |            |                    |                   |
  |-- Click ------>|            |                    |                   |
  |   "Refresh"    |            |                    |                   |
  |                |-- API ---->|                    |                   |
  |                |   Call     |-- POST /info ----->|                   |
  |                |            |                    |-- connect() ----->|
  |                |            |                    |-- exec() -------->|
  |                |            |                    |<-- result --------|
  |                |            |<-- Response -------|                   |
  |                |<-- Data ---|                    |-- disconnect() -->|
  |<-- Display ----|            |                    |                   |
```

---

## 5. 구현 체크리스트

### Frontend

#### 5.1 환경 설정
- [ ] Vue 3 프로젝트 생성 (Vite, TypeScript)
- [ ] 의존성 설치
  - [ ] `pinia` (상태 관리)
  - [ ] `vue-router` (라우팅)
  - [ ] `xterm` (터미널)
  - [ ] `@xterm/addon-fit` (터미널 크기 조정)
  - [ ] `@stomp/stompjs` (WebSocket)
  - [ ] `sockjs-client` (WebSocket fallback)
- [ ] TypeScript 설정 (tsconfig.json)
- [ ] Vite 설정 (프록시 설정)

#### 5.2 프로젝트 구조
- [ ] `src/types/` 디렉토리 생성 및 타입 정의
  - [ ] connection.ts
  - [ ] terminal.ts
  - [ ] api.ts
- [ ] `src/stores/` 디렉토리 생성
- [ ] `src/composables/` 디렉토리 생성
- [ ] `src/components/` 디렉토리 생성
- [ ] `src/views/` 디렉토리 생성

#### 5.3 Pinia Store
- [ ] connectionStore.ts 구현
  - [ ] State 정의 (connections, selectedConnectionId)
  - [ ] Getter (selectedConnection)
  - [ ] Actions (load, save, add, remove, select)
  - [ ] LocalStorage 연동

#### 5.4 Composables
- [ ] useSshConnection.ts 구현
  - [ ] validateConnection() API 호출
  - [ ] getServerInfo() API 호출
  - [ ] 에러 처리
- [ ] useTerminal.ts 구현
  - [ ] xterm.js 인스턴스 생성
  - [ ] FitAddon 연동
  - [ ] 터미널 초기화 및 정리
  - [ ] 데이터 쓰기 메서드
- [ ] useWebSocket.ts 구현
  - [ ] STOMP 클라이언트 설정
  - [ ] connect/disconnect 메서드
  - [ ] sendInput/sendResize 메서드
  - [ ] 메시지 콜백 관리
  - [ ] 에러 및 종료 처리

#### 5.5 Components
- [ ] App.vue
  - [ ] 전역 스타일 설정
  - [ ] RouterView 설정
- [ ] MainView.vue
  - [ ] 2/7/1 레이아웃 구현
  - [ ] 반응형 디자인 (최소 너비 설정)
- [ ] LeftSidebar.vue
  - [ ] 헤더 및 "Add" 버튼
  - [ ] 연결 목록 렌더링
  - [ ] 빈 상태 표시
  - [ ] ConnectionForm 모달 표시
- [ ] ConnectionItem.vue
  - [ ] 연결 정보 카드 디자인
  - [ ] 선택 상태 표시
  - [ ] 삭제 버튼 호버 효과
- [ ] ConnectionForm.vue
  - [ ] 모달 레이아웃
  - [ ] 폼 필드 (name, host, port, username, authType, password/privateKey)
  - [ ] 실시간 validation
  - [ ] "Test Connection" 기능
  - [ ] "Save" 및 "Cancel" 버튼
- [ ] TerminalPanel.vue
  - [ ] 터미널 툴바 (상태 표시, Disconnect 버튼)
  - [ ] xterm.js 마운트
  - [ ] WebSocket 연결 관리
  - [ ] 에러 오버레이
  - [ ] Welcome 화면
  - [ ] 터미널 리사이즈 이벤트 처리
- [ ] RightPanel.vue
  - [ ] 헤더 및 "Refresh" 버튼
  - [ ] 서버 정보 표시
  - [ ] 빈 상태 표시
  - [ ] 로딩 상태 표시

#### 5.6 Routing
- [ ] vue-router 설정
  - [ ] MainView 라우트 등록 (`/`)

#### 5.7 스타일링
- [ ] 전역 CSS (다크 테마)
- [ ] xterm.js 테마 설정 (VSCode 다크 테마 스타일)
- [ ] 컴포넌트별 scoped 스타일
- [ ] 반응형 디자인 (최소 1024px 권장)

#### 5.8 LocalStorage 관리
- [ ] 연결 정보 저장/로드
- [ ] JSON 직렬화/역직렬화
- [ ] 에러 처리 (localStorage 접근 실패)

#### 5.9 에러 처리
- [ ] API 호출 에러 처리
- [ ] WebSocket 연결 에러 처리
- [ ] 사용자 피드백 (alert, 에러 오버레이)

#### 5.10 테스트
- [ ] 컴포넌트 단위 테스트 (선택사항 - MVP)
- [ ] E2E 테스트 (선택사항 - MVP)

---

## 6. 참고사항

### 6.1 보안 고려사항

1. **LocalStorage 사용**
   - 연결 정보는 평문으로 저장됨 (브라우저 LocalStorage)
   - 민감한 정보(비밀번호, Private Key)도 포함되므로 사용자 주의 필요
   - MVP에서는 암호화 미적용, 향후 Web Crypto API 사용 고려

2. **메모리 관리**
   - 비밀번호 및 Private Key는 메모리에서만 처리
   - 컴포넌트 언마운트 시 민감 데이터 정리

3. **XSS 방지**
   - Vue의 기본 템플릿 바인딩 사용 (v-html 사용 금지)
   - 사용자 입력 sanitize

### 6.2 UX 고려사항

1. **로딩 상태**
   - API 호출 중: 버튼 비활성화 및 로딩 텍스트 표시
   - WebSocket 연결 중: "Connecting..." 상태 표시

2. **에러 메시지**
   - 명확하고 실행 가능한 에러 메시지 제공
   - 연결 실패 시 원인 표시 (인증 실패, 타임아웃 등)

3. **반응형 디자인**
   - 최소 1024px 너비 권장
   - 터미널은 가로 스크롤 방지 (fit 사용)

4. **키보드 접근성**
   - 터미널 자동 포커스
   - ESC 키로 모달 닫기

### 6.3 성능 고려사항

1. **터미널 렌더링**
   - xterm.js FitAddon으로 크기 자동 조정
   - debounce 적용 (resize 이벤트)

2. **WebSocket 메시지**
   - 출력 데이터 버퍼링 (서버에서 처리)
   - 클라이언트는 즉시 렌더링

3. **LocalStorage**
   - 연결 추가/삭제 시에만 저장
   - 대량 연결 목록 처리 시 성능 고려 (향후 IndexedDB 전환)

### 6.4 브라우저 호환성

- Chrome 90+
- Firefox 88+
- Safari 14+
- Edge 90+

**필수 기능:**
- LocalStorage API
- WebSocket
- ES2020 (Promise, async/await 등)

### 6.5 Vite 프록시 설정

```typescript
// vite.config.ts
export default defineConfig({
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
      },
      '/ws': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        ws: true,
      },
    },
  },
});
```

### 6.6 의존성 (package.json)

```json
{
  "dependencies": {
    "vue": "^3.4.0",
    "vue-router": "^4.2.0",
    "pinia": "^2.1.0",
    "xterm": "^5.3.0",
    "@xterm/addon-fit": "^0.10.0",
    "@stomp/stompjs": "^7.0.0",
    "sockjs-client": "^1.6.1"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.0",
    "typescript": "^5.3.0",
    "vite": "^5.0.0",
    "vue-tsc": "^1.8.0"
  }
}
```

### 6.7 환경 변수

```env
# .env.development
VITE_API_BASE_URL=http://localhost:8080
VITE_WS_URL=http://localhost:8080/ws/terminal
```

```env
# .env.production
VITE_API_BASE_URL=/api
VITE_WS_URL=/ws/terminal
```

---

## 7. 디렉토리 구조 (최종)

```
ui/
├── public/
├── src/
│   ├── App.vue
│   ├── main.ts
│   ├── router/
│   │   └── index.ts
│   ├── stores/
│   │   └── connectionStore.ts
│   ├── composables/
│   │   ├── useSshConnection.ts
│   │   ├── useTerminal.ts
│   │   └── useWebSocket.ts
│   ├── components/
│   │   ├── LeftSidebar.vue
│   │   ├── ConnectionItem.vue
│   │   ├── ConnectionForm.vue
│   │   ├── TerminalPanel.vue
│   │   └── RightPanel.vue
│   ├── views/
│   │   └── MainView.vue
│   ├── types/
│   │   ├── connection.ts
│   │   ├── terminal.ts
│   │   └── api.ts
│   └── assets/
│       └── styles/
│           └── global.css
├── package.json
├── tsconfig.json
├── vite.config.ts
└── index.html
```

---

**작성일:** 2025-12-19
**버전:** 1.0 (MVP)
**담당:** Frontend Team
